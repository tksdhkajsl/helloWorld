// helloWorld.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//소스파일
//주석(Comment) : 컴파일러가 무시하는 문장 
 /* 단락 주석
 /* 단락 주석 ctrl+d 한줄 복사
 * shift+Del 한줄 삭제
   shift+화살표 :  블록 잡기
   shift+alt+화살표 : 선택 세로줄 블록 잡기 
   ctrl+space : 자동 완성 기능 (인텔리전스) 띄우기
   //alt+위/아래 : 코드 줄 바꾸기
   F5 디버그 시작
   ctrl+b+b : 프로젝트 빌드 
   ctrl+상하 : 페이지 업/다운
   ctrl+좌우 : 단어별 띄우기
   ctrl+k+c : 블록 주석 처리
   ctrl+k+u : 블록 주석 해제
   shift+9(() : 선택한 문장 소괄호 치기
 */
// 프로그램 실행 시 영향을 주지 않는 부분
/*
컴파일러 : 사람이 작성한 코드를 컴퓨터가  이해할 수 있게 번역하는 것
 목적 코드 생성
 링커가 연결해서 실행파일 생성
 빌드 : 실행파일 생성하기
 리빌드 : 전체 재빌드 ctrl+b+r
 pdb 모든 코드 자료 포함되어 있음. 보안 필수 
 브랜치 분기 -git을 사용하여 분기점 지정 후 사용 가능
 
 브랜치 분기
 변수는 사용하기 직전에 선언한다.
*/
#define _CRTDBG_MAP_ALLOC
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#define _CRT_SECURE_NO_WARNINGS
#include <crtdbg.h>
#include <iostream> //입출력 관련
#include <cstdio>  // stdio.h에 네임 스페이스 추가한 래퍼
#include <stdio.h>
#include "header.h"
#include <time.h>
#include <random>
//#include "Position.h"
//#include "BlackJack.h"
#include "TestMath.h"
#include "Practice.h"
#include "Practice_250909.h"
#include "Practice_250910.h"
#include "Practice_250911.h"
#include "Practice_250912.h"
#include "Practice_250915.h"
#include "WeekWork_0913.h"
#include <fstream>
#include <limits.h>
#include "Day_250916.h"
#include "Car.h"
#include "Day0917.h"
#include "Day0918.h"
#include "Day0919.h"

//using namespace std;
//
//int Number = Sum(1, 7); //Sum 함수를 호출했다. 파라메터로 1과 7을 넘겼다. 그리고 8을 돌려 받았다.
//
//Number = Multiply(2, 3);
//Number = Multiply(7);
//
//Number = Sub(5, 4);
//Number = Divide(12, 4);
//
///*
//재귀호출(Recurcive Call)
//	-함수 안에서 자기자신을 다시 호출하는 함수
//*/
///*
//템플릿(template) 함수
//	- 데이터 타입에 관계 없이 동일한 로직을 여러 자료형에 대해 사용할 수 있게 해주는 C++ 기능
//	- 컴파일 타임(빌드 시간)에 실제 사용하는 곳이 있으면 해당 타입으로 코드 생성한다.
//	->해더에 선언과 구현이 함께 있어야 한다.
//	런 타임(실행 시간)
//*/
//
///*
//인라인(Inline) 함수
//	- 함수 호출문을 해당 함수의 실체 코드로 대체하는 함수
//*/
///*
//스코프(Scorp)
//	- 변수,함수, 객체 등이 유효하게 사용할 수 있는 범위
//	- 일반적으로 선언된 중괄호 안쪽에서만 유효
//	- 지역 변수 : 특정 함수 내에서 선언된 변수
//	- 전역 변수 : 프로그램 전체에서 사용할 수 있는 변수
//*/
////TestRecurcive(5);
////
////float Number2 = Add(10.5f, 20.4f);
////
////int Number3 = Square(2);
////int Number3 = Number * Number;
////
////getchar();
////getchar();
//
//return 0;
//

	/*
	배열(Array)(선형자료구조)
		- 같은 데이터 타입을 가진 요소들이 연속적으로 저장되어 있는 데이터 구조
		- 장점 : 빠르게 각 요소에 접근이 가능
		- 단점 : 크기가 고정이다. 중간에 데이터 삽입/삭제가 어렵다.
	*/

	/*
	캐스팅(Casting)
		- 하나의 타입을 다른 데이터 타입으로 변경하는 것
	//a = (int)b;//b를 int로 캐스팅해서 a에 대입한다.(C스타일 명시적 캐스팅)
	//a = b;	//b를 a에 대입한다. 그런데 a와 b는 타입이 다르니까 b를 a로 임시적으로 캐스팅 대입(암시적 캐스팅)
	//b = a; //암시적 캐스팅은 대체로 표현이 작은 쪽에서 큰쪽으로는 문제없는 경우가 많다.

	////C++ 캐스팅
	////static_cast : C스타일 캐스팅을 안전하게 만든 것. 컴파일 타임에 결정됨.
	////dynamic_cast 클래스
	////const_cast : const 속성 제거하거나 추가하는데 사용. 사용하지 않는 것이 권장. 오래된 코드에서 사용
	////reinterpret_cast : C스타일 캐스팅에서 위험한 부분. 원래 타입의 구조를 무시하고 새 타입으로 해석하게 한다.

	//a = static_cast<int>(b); //b를 int형으로 캐스팅해서 a에 대입(명시적 캐스팅 C++)
	*/
	/*		포인터(Pointer)
			- 메모리 주소를 저장하는 데이터 타입
			- 각 데이터 타입에 *만 붙이면 포인터 타입
			ex)int* 인터저 포인터, float* , char*
			-	주소 연산자(&) : 변수의 주소를 가져온다.
					int i =10;
					int* p = &i; i의 주소를 int* p에 대입해라.
					int Numbers =1012;
					(&Numbers;)
			- 포인터 연산자
			-	간접참조 연산자(*) : 포인터 변수가 가리키는 주소의 실제 값
				int i = 20;
				int* p = &i;
				(*p) = 30;  i = 30;과 같다
			-산술 연산자(+,-,++,--)
			int i 30;
			int* p = &i;
			p = p + 1;  //예시로 p가 0x0004라고 했을 때 p + 1 값은 0x0008
			double d = 10.5;
			double* pD = &d;
			pD += 1; //pD가 원래 0x0000이라 했을 때 pD +=1 는 0x0008
			*/
			//배열과 포인터 (기본적으로 같다)

		/*int* p = nullptr;*/
		//int *p2 = nullptr;
		/*
		C++의 메모리 영역(단순화된 버전)
		-코드 영역 : 실행코드가 저장되는 공간

		-데이터 영역 : 프로그램이 시작할 때부터 끝날때까지 유지되는 변수가 저장되는 공간

		-힙 영역 : 램 그 자체 프로그램이 실행 중에 필요에 따라 직접 메모리를 할당 받고 사용하는 공간
			- 운영체제가 관리하기 떄문에 힙을 할당 받는 행위는 느리다.
			- 메모리를 할당 받았으면 사용 후 반드시 해제해야 한다.(메모리 릭(메모리 누수) 발생)
		-스택 영역 : 함수가 호출 될 때마다 필요한 변수(지역 변수)가 저장되는 공간
			- 함수가 끝나면 자동으로 정리
		*/
		/*
		정적(static) : 프로그램 실행 전에 이미 결정난 것들
		동적(Dynamic) : 프로그램 실행 중에 결정이 되는 것들
		*/
		/*
		동적 할당Dynamic Allocatoin)
			- 프로그램 실행 중(Runtime)에 메모리를 사용하기 위해 확보하는 행위
			- 운영체제(OS)에게 요청함 -> 그래서 늦다.
			- C 스타일
				할당 : malloc
				해제 : free
				단순 메모리 블럭만 받는 형식(초기화 없음, 타입 안정성 없음, 생성자/소멸자 실행X)
			- C++ 스타일
			-	할당 : new
			-	해제 : 일반 변수delete, 배열 delete[]
				int* Data = new int(5); int 하나를 할당 받는데 주소가 가르키는 값은 5로 설정해라
				delete Data;
				Data = nullptr;
				int* Array = new int[10]; int 10개짜리 배열을 만들어라
				delete[] Array; 배열은 반드시 해당 식으로 해제 (delete Array; 배열의 1번째만 해제)
				Array = nullptr;
				특정 객체(Object)를 생성하는 방식(초기화가 있다. 타입 안정성이 있다/생성자와 소멸자가 있다.)
			- 메모리 할당과 성능 문제
				메모리 할당은  오래 걸린다.(컴퓨터 입장에서 느리다. 운영체제 메모리관리나 적절한 사이즈를 찾는데 시간이 걸림)
				메모리 단편화 문제(메모리 할당 해제를 반복하다가 전체 빈공간은 충분한데. 연속된 빈공간이 부족해지는 현상)
				CPU 캐시 히트 ,
			-메모리 릭
				할당한 메모리를 반환하지 않아 해당 영역을 사용하지 못하게 되는 현상


		*/
	/*문자열
		- 글자 여러개를 모아 문장을 만들어 놓은 것
		- C언어에서는 문자열을 표현하기 위해 char* 사용.(== char[])
		- 항상 마지막 문자열은 Null 문자 \0으로 끝난다
		- char*에는 아스키 코드가 기록된다.
	
	*/
	/*
	파싱(Parsing)
		- 문자열을 분석해서 의미있는 정보로 변환하는 과정

	*/
	/*
	구조체(Struct)
		- 여러 종류의 데이터타입을 하나로 묶을 때 사용.
		-	프로그램 코드의 가독성과 유지 보수성을 향상시켜 준다.
		struct Enemy
		{
			std::string Name;
			float Health;
			float AttackPower;
			int DropGold;
		}

		Enemy goblin; //적 하나에 대한 정보 만들기
		Enemy goblin[3]; //적 3 마리에 대한 정보 만들기

		- 구조체 동적 할당하는 법
		Enemy* pGoblin = new Enemy(); // 새 적을 동적 할당 받음
		delete pGoblin;					// 동적할당 받은 것 해제
		pGoblin = nullptr;			
		
		- 구조체 데이터 접근법
			- 일반적인 경우 점(.) 연산자 사용
		goblin.Name = "고블린";
		goblin.Health = 20;
			- 포인터 변수인 경우 화살표(->) 연산자 사용
		pGoblin->AttackPower = 5.0f;
		pGoblin->DropGold = 10;

		- 구조체의 생성자
			- 객체가 만들어질 때 자동으로 호출되는 특별한 함수
			- 객체
			int i = 10; //하나의 인티저 객체 i 생성
			int Array[3]; //인티저 객체 3개 생성
			Enemy* pEnemy = new Enemy();	// Enemy 객체 하나가 만들어짐

			- 맴버 변수 초기화에 사용(값을 계산하거나 변경해서 넣을 때 좋음)
			- 일반 함수와 다른 특징
				1. 이름이 구조체 이름과 같아야 함.
				2. 리턴 타입 X
				3. 객체가 만들어질 때 자동으로 호출됨.
				4. 생성자가 여러개 있을 수도 있다.
				5. 없으면 기본 생성자가 자동으로 만들어진다.(무조건 하나는 있다.)


		- 구조체의 명령어 오버로딩(덮어쓰기)
			- 
	*/
	/*Practice0905_01();
		Practice0905_02();*/

		/*float Value = Clamp(5.2f, 7.3f, 8.0f);
		printf("%.2f", Value);*/
		/*DiceResult();

		PointGrade(88);


		int Value = SalePrice(43000,50);
		printf("%d", Value);*/
		//int a = 10;
		//int Array[5]; //int 5개를 관리하는 배열
		//Array[0] = 10; //배열의 첫 번째 요소에 10을 대입한다.
		//Array[3] = 40; //배열의 4 번째 요소에 40을 대입한다.

		//int Array2[5] = { 1,2,3,4,5 };
		//int Array3[5] = { 1,2,3 };

		//int Array4[5] = {};
		//const int Size = 5;
		//int Array5[Size] = {};
		//sizeof(Array5); //Array5의 전체 바이트 크기를 알수 있다.
		//sizeof(Array5[0]); //Array5의 요소 하나의 크기를 알 수 있다.
		//int ElementCount = sizeof(Array5) / sizeof(Array5[0]); //배열 요소의 개수
		//int Size2 = 5;
		// int Array6[Size2] = {}; 배열 선언할 때 크기를 변수로 지정할 수 없다.
		//Array[5] = 60; //원래는 터짐 버퍼오버런 ,배열 영역 밖을 접근하려고 하기 때문에 에러 발생 //키워드 문법적으로 이미 정해진 것
		// 간단 실습
		//1. 배열을 만들고 초기화 해보기
		//int Numbers[3] = { 23,4,5 };

		////2. 배열의 모든 요소의 값을 더하고 평균 구하기
		//int Array[5] = { 1,2,3,4,5 };
		//float ArrayAverage = 0.0f;
		//int ArraySum = 0;
		//int ArrayCount = static_cast<int>(sizeof(Numbers) / sizeof(Numbers[0]));
		//for (int i = 0; i <ArrayCount; i++)
		//{
		//	ArraySum += Numbers[i];		
		//}
		//ArrayAverage = ArraySum/static_cast<float>(ArrayCount);
		//printf("배열의 모든 요소 더한 값은 %d 이고 평균은 %.2f이다.\n", ArraySum, ArrayAverage);
		////3. 배열의 모든 요소 중 최대값과 최소값 구하기
		//int MaxNumber = INT_MIN;
		//int MinNumber = INT_MAX;
		//for (int i = 0; i < ArrayCount; i++)
		//{
		//	if (MaxNumber < Numbers[i])
		//	{

		//		MaxNumber = Numbers[i];
		//	}
		//	if (MinNumber > Numbers[i])
		//	{
		//		MinNumber = Numbers[i];
		//	}
		//}

		/*
		이차원 배열
			- 배열을 이차원으로 표현한 것
			- int Array[4][3] = { {1,2,3},{4,5,6},{7,8,9},{0,1,2} };
			int 3개 짜리 배열이 4줄 들어있다.
			사실 int Array[12] 랑 메모리 구조가 같다.
		*/
		//int Array7[4][3] = { {1,2,3},{4,5,6},{7,8,9},{0,1,2} };
		//int test = Array7[1][2]; //test = 6
		//int Array8[12] = { 1,2,3,4,5,6,7,8,9,0,1,2 };

		/*int Array9[9] = { 1,2,3,4,5,6,7,8,9 };
		BackArray(Array9,9);*/


		/*
		피셔-에이츠 알고리즘
			- 배역의 내용을 랜덤하게 겄는 셔플 알고리즘
			- 동일한 확률로 섞이도록 증명 완료된 알고리즘

			- 알고리즘 순서
				1. 배역의 마지막 요소에서 첫 요소까지 순회
				2. 현재 요소의 인덱스(I)와 0 ~ i 중 임의의 인덱스(j)를 선택한다.
				3. i번째 와 j번째 요소를 서로 교환
				4. i가 0이 될 때까지 반복
		*/
		/*Day0908_Dice();*/
		/*
		참조(Referance)
			- 변수에 별명
			- 참조를 변경할 경우 원본 변수고 함께 수정이 된다. -> 함수 파라메터로 사용하면 편리
			- 참조는 항상 어떤 변수와 연결되어 있어야 함.
			함수 파라메터에 참조를 사용할 때
				-파라메터 값을 수정하는 출력용 파라메터일 경우 out이라는 접두사
				= 파라메터 값을 읽기만 하는 경우에는 const
		*/

//객체지향
/*	- 객체(Object) : 게임 상에 존재하는 모든 것
*	- 객체지향 : 객체를 중심으로 프로그램을 설계하는 것
*	- 클래스(Class) : 객체를 만들기 위한 설계도 
		객체가 가져야 할 상태(데이터)와 동작(기능)을 하나로 묶어 놓은 것
	- 객체지향의 4대 특성
		- 추상화
			- 불필요한 세부 사항은 숨기고, 핵심적인 부분만 보여주는 것
			- 코드의 복잡성을 낮춘다.(이해하기 쉽다.)
		- 캡슐화
			- 접근 제한자를 통한 데이터의 접근제어
			- 몰라도 되는 것은 안보여야 한다.(데이터를 보호하고 코드의 안정성을 높이고 결합도도 낮춘다)
		- 상속
			- 부모 클래스(기본)의 데이터와 기능을 물려받은 자식 클래스(파생)를 만드는 것
			- 코드의 재사용성을 높이고 계층 구조를 형성한다.
		- 다형성
			- 동일한 인터페이스를 통해 다양한 처리를 하는 것
			- 가상 함수의 오버라이드를 통한 다형성 구현
* 

*/
//클래스
/*
	- 객체를 만들기 위한 설계도
	- 객체가 가지게 될 상태와 동작을 하나로 묶어 놓은 것
	- 인스턴스 : 클래스를 기반으로 실제 메모리에 만들어진 실체(new 하는 것)
	- 구성요소
		- 생성자 : 구조체와 같음. 객체를 생성했을 때 자동 호출되는 특별한  함수
		- 소멸자 : 구조체나 객체가 해제될 때 자동으로 호출되는 특별한 함수
			- 객체가 사용하던 자원을 깨끗이 정리하는 역할
			- 클래스 내부에서 동적할당한 메모리를 해제하는데 주로 사용(메모리 릭 방지)
		- 맴버 변수 : 객체의 상태나 데이터를 저장하는 변수 (속성 ,필드라고도 함)
		- 맴버 함수 : 객체가 할 수 있는 동작이나 기능을 정의한 함수(메소드 method)

*/
//접근 제한자(Access Modifier)
/*
	- 이 객체의 내부를 누구까지 볼 수 있는지 설정
	- public, protected, private
	- public : 누구든지 접근 가능
	- private : 나만 접근 가능(캡슐화)
	- protected : 나와 나를 상속받은 대상만 접근 가능
	- 구조체의 접근제한자 : 설정안하면 기본적으로 public
	- 클래스의 접근제한자 : 설정안하면 기본적으로 private
*/
//상속
/*
	- 부모 클래스의 맴버를 물려 받는 행위
	- 특징
		- 코드 재사용성이 높다
		- 계층구조로 객체들의 관계를 명확히 할 수 있다.
		- 부모 클래스의 포인터나 참조를 통해 자식 클래스를 다룰 수 있다.
*/

//가상함수
/*
	- 부모클래스에서 함수의 선언 앞에다가 virtual을 붙이면 된다.
	- 자식 클래스는 부모의 가상함수를 덮어쓸 경우에만 함수의 선언 앞에 virtual이라고 쓰고 뒤에 override라고 붙인다.
	- 주의 : 상속을 하거나 받았으면, 소멸자를 무조건 가상함수 처리
	- 가상 테이블(vtable)
		- 클래스에 가상 함수가 하나라도 있으면 자동 생성
		- 그 클래스의 가상 함수들의 주소 목록을 저장해놓은 테이블	

*/

//dynamic_cast
/*
	- 런타임(실행중)에 이 주소가 실제 어떤 자식 클래스의 객체를 가리키고 있는지 안전하게 확인해주는 cast
	- 부모 클래스에 반드시 하나 이상의 가상함수가 있어야 함(vtable이 있어야 하기 떄문에)
	Child* pChild = dynamic_cast<Child*>(pParent);
	- 속도가 늦기 떄문에 가능한 적게 쓰는게 좋다.

- 다이아몬드 상속 문제 : 다중 상속 시 발생하는 대표적 문제
*/
//순수 가상 함수
//	- 가상함수인데 구현을 0으로 표시해놓은 것
//	- 선언만 있고 구현이 없다
//	- 순수 가상함수를 가진 클래스를 상속 받은 클래스는 반드시 순수 가상함수를 override 해서 구현해야 함

//추상클래스
/*
	- 하나 이상의 순수 가상 함수를 포함하는 클래스
	- 다른 클래스가 상속받을 기본 틀을 제공하기 위해 사용
	- 인스턴스화 할 수 없다. -> 상속받은 클래스에서 순수 가상함수를 override한 후에 인스턴스화 가능
*/

//인터페이스
/*
	- 이 클래스는 "이런 일을 할 수 있다"라고 알려주는 것 -> 이런 일을 수행하는 함수가 존재해야만 한다.
	- 클래스가 반드시 구현해야 할 맴버 함수들의 명세를 정의하기 위해 사용
	- 주의 사항
		- 이름은 무조건 대문자 'I'로 시작 필수적 관례
		- 맴버는 순수 가상 함수만 있다.(소멸자 제외)

	*/

//enum 클래스
/*
	- enum : 상수의 집합
	- enum class : 더 안전해진 enum.(안전해진만큼 불편해진 부분도 있음)
		- enum class는 코드의 명확성과 안정성을 향상시킨다.
		- enum의 데이터 크기 설정도 가능하다.
	enum AnimalType
	{
		Dog, Cat, Tiger
	}
	enum class AnimalType : uint_t
	{
		Dog, Cat, Tiger
	}
*/
//자료구조(Data Structure)
/*
	- 데이터를 효율적으로 관리하는 방법(특정한 구조와 규칙이 있음)
	- 목적
		- 더 빠르게 데이터를 처리한다.(CPU 자원 절약)
		- 더 효율적이게 데이터를 관리(메모리 자원 절약)
		- 문제 해결을 위한 구조 제공
	- 종류
		- 배열
		- 리스트
		- 스텍
		- 큐
		- 트리
		- 그래프
*/
/*
	배열
		- 동일한 타입의 데이터를 연속된 메모리 공간에 저장
		- 인덱스를 통해 데이터에 직접 접근
		- 장점
			- 접근 속도가 빠르다 ( O(1) <- 시간 복잡도, 빅오 표기법)
			- 구조가 단순하다
			- 별도의 오버헤드가 없다
		- 단점
			- 데이터 추가/삭제가 매우 느림(O(n))
			- 생성시 크기가 고정되어 있어 유연성이 떨어짐
*/

//리스트(Linked List) 이점: 버프/디버프, 속도 턴 게임  단점 : 랜덤 엑세스 (맵 등)
/*
	- 데이터가 포인터로 연결된 형태
		- 논리적으로 하나의 줄을 만든다.(선형 자료구조)
	- 노드(데이터 하나를 표현)
		- 자료구조에서 데이터 하나를 가리키는 구조
		- 리스트의 노드는 데이터와 다음 노드를 가리키는 주소로 이루어져 있다.
	- 주요 구성 요소
		- head : 리스트의 첫번째 구조
		- tail : 리스트의 마지막 구조
	- 장점
		- 데이터의 추가/삭제가 쉽다.
		- 크기가 동적으로 변할 수 있어 유연함
	- 단점
		- 탐색 속도가 느리다(처음부터 순서대로 찾아야 한다.)
		- 다음 노드를 저장하기 위한 포인터를 위해 추가 메모리 공간이 필요(오버헤드)

*/
/*
	빅오 표기법
		- 알고리즘의 시간 복잡도를 나태내는 방법
		- O(1) : 알고리즘을 돌릴 때 데이터의 개수와 상관없이 항상 일정한 속도를 유지
		- O(n) : 알고리즘을 돌릴 때 데이터의 개수에 비례해서 속도가 느려진다.
		- O(logN) : 알고리즘을 돌릴 때 속도가 로그 그래프에 비례한다.(많아질 수록 유리하다.)
*/
//스텍(Stack)
/*
	- 특징
		- 후입선출(LIFO) 구조
		- 구조
		- 속성(맴버 변수)
			- Top : 데이터 입출력 위치
		- 기능(맴버 함수)
			- Push : Top에 데이터 추가
			- Pop : Top 에서 데이터 가져오기
	- 장점
		- 구조가 단순 구현이 쉬움
		- 데이터 저장 및 읽기 속도가 빠르다.
		적절한 사용 예시
			- UI, 실행취소,함수 콜 스택 등등
	- 단점
		- 맨 위의 데이터 외에는 접근하거나 탐색할 수 없음
		- 기능이 단순하여 활용도가 제한적이다.

*/
// 큐(Queue)
/*	득징
	- 선입선출 FIFO 구조, 먼저 들어온 것이 먼저 나간다.
	- 구조
		- 속성
		- Front : 큐의 제일 앞, 항상 데이터는 여기서 제거 
		- Rear : 큐의 마지막 항상 데이터는 여기에 추가된다.
		- 기능
		- Enqueue : Rear에서 데이터를 추가하는 함수
		- Dequeue : Front에서 데이터를 뺴는 함수
	- 장점
		- 순차적으로 데이터를 처리할 때 유용
		- 대기표,식당 줄, 매칭 큐 등등 활용

	- 단점
		- 중간에 있는 데이터에 접근하거나 탐색 불가능
		- 기능이 단순하여 활용도가 제한적이다.
*/
//얕은 복사
/*
	- 할당된 메모리를 복사할 때 주소만 복사하는 것
	- 장점 : 빠르다
	- 단점 : 댕글링 포인터를 만들지 않게 하기 위해 신경써야 한다.
	- 구조체나 클래스는 함수 파라메터로 넘길 때 참조나 포인터로만 넘겨라
*/
// 
//static_cast<float>(rand()) / static_cast<float>(RAND_MAX); float 기본 랜덤 값 0.0 ~ 1.0(백분률)
int main() //엔트리 포인트 : 코드가 시작되는 곳
{
	
	
	//Day0912_OperatorOverloading();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	//Day0909_DynamicAllocation();
	
	//Day0909_Example();

	//MazeEscapeRun();
	//Date(2,1,1);
	//HighRow();
	//Day0910_String();
	//Day0911();Date
	//Day0912_Struct();

	/*Position pos(1, 2);
	Position* pPos = new Position(2, 3);

	delete pPos;
	pPos = nullptr;*/
	//Position posA(1, 2);
	//Position posB(3, -1);
	//Position posC = posA + posB;
	//Position posD = posA - posB;

	//int i = 0;
	////Position pos2;
	//Position pos2 = Position();
	//Day0915_WeekPracticeTest();
	//Day0915_WeekPracticeBlackJackTest();
	//srand(time(0));
	//PlayBlackjack();
	//Play();
	//Day0917 day0917;
	////day0917.TestPolymorphism();
	//day0917.TestPratice1();

	//Day_250916 day_250916;
	//day_250916.ClassInstance();
	/*day_250916.AnimalTiger();
	day_250916.AnimalLion();
	day_250916.AnimalWolf();
	day_250916.AnimalRabbit();*/
	/*Day0918 day0918;
	day0918.TestSingleLinkedList();*/
	
	Day0919 day0919;
	day0919.TestQueue();
	return 0;

}


// 프로그램 실행: <Ctrl+F5> 또는 [디버그] > [디버깅하지 않고 시작] 메뉴
// 프로그램 디버그: <F5> 키 또는 [디버그] > [디버깅 시작] 메뉴


// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
